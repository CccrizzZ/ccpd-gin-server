package invoices

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/dslipak/pdf"
	"github.com/gin-gonic/gin"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

var timeFormat string = "2006-01-02T15:04:05Z07:00"

type Invoice struct {
	InvoiceNumber string  `json:"invoiceNumber" binding:"required" validate:"required"`
	Time          string  `json:"time" binding:"required" validate:"required"`
	BuyerName     string  `json:"buyerName" binding:"required" validate:"required"`
	BuyerEmail    string  `json:"buyerEmail" binding:"required" validate:"required"`
	BuyerAddress  string  `json:"buyerAddress" binding:"required" validate:"required"`
	BuyerPhone    string  `json:"buyerPhone" binding:"required" validate:"required"`
	AuctionLot    int     `json:"auctionLot" binding:"required" validate:"required"`
	InvoiceTotal  float32 `json:"invoiceTotal" binding:"required"`
	Message       string  `json:"message" binding:"required" validate:"required"`
	Items         []InvoiceItem
}

type InvoiceItem struct {
	Sku           int     `json:"sku"`
	Msrp          string  `json:"msrp"`
	ShelfLocation string  `json:"shelfLocation"`
	ItemLot       int     `json:"itemLot"`
	Desc          string  `json:"description"`
	Unit          int     `json:"unit"`
	UnitPrice     float32 `json:"unitPrice"`
	ExtendedPrice float32 `json:"extendedPrice"` // unit * unitPrice
	HandlingFee   float32 `json:"handlingFee"`
}

func CreateInvoice() gin.HandlerFunc {
	return func(c *gin.Context) {
		// ctx := context.Background()
		var newInvoice Invoice
		bindErr := c.ShouldBindJSON(&newInvoice)
		if bindErr != nil {
			c.String(http.StatusBadRequest, "Invalid Body")
			return
		}
	}
}

// generated by chat gpt
// parse the extracted text from pdf to object
func parseInvoice(text string) Invoice {
	// auction lot number
	auctionLotPattern := regexp.MustCompile(`Auction Sale - (\d+)`)
	auctionLotMatch := auctionLotPattern.FindStringSubmatch(text)
	var auctionLot int
	if len(auctionLotMatch) > 1 {
		auctionLot, _ = strconv.Atoi(auctionLotMatch[1])
	}

	// Extract invoice number
	invoiceNumberPattern := regexp.MustCompile(`\s+1\s+(\d+)\s*Auction Sale`)
	invoiceNumberMatch := invoiceNumberPattern.FindStringSubmatch(text)
	var invoiceNumber string
	if len(invoiceNumberMatch) > 1 {
		invoiceNumber = strings.TrimSpace(invoiceNumberMatch[1])
	}

	fmt.Println(invoiceNumber)

	// Extract time
	timePattern := regexp.MustCompile(`(\d{1,2}/\d{1,2}/\d{4}\s+\d{1,2}:\d{2}:\d{2})`)
	timeMatch := timePattern.FindStringSubmatch(text)
	var time string
	if len(timeMatch) > 1 {
		time = strings.TrimSpace(timeMatch[1])
	}

	// buyer name & address
	buyerNamePattern := regexp.MustCompile(`SOLD TO:\s*(.*?)SHIP TO:`)
	buyerNameAddressMatch := buyerNamePattern.FindStringSubmatch(text)
	var buyerName string
	var buyerAddress string
	if len(buyerNameAddressMatch) > 1 {
		buyerInfo := strings.TrimSpace(buyerNameAddressMatch[1])
		// the name will follow by street number
		// split by street number
		re := regexp.MustCompile(`\d`)
		firstNumberIndex := re.FindStringIndex(buyerInfo)
		if firstNumberIndex != nil {
			buyerName = strings.TrimSpace(buyerInfo[:firstNumberIndex[0]])
			buyerAddress = strings.TrimSpace(buyerInfo[firstNumberIndex[0]:])
		} else {
			// if buyer address started with letter, its not gonna detect
			buyerName = buyerInfo
		}
	}

	// buyer phone
	buyerPhonePattern := regexp.MustCompile(`Phone:\s*(.*?)\s*#`)
	buyerPhoneMatch := buyerPhonePattern.FindStringSubmatch(text)
	var buyerPhone string
	if len(buyerPhoneMatch) > 1 {
		buyerPhone = strings.TrimSpace(buyerPhoneMatch[1])
	}

	// buyer email
	// buyerEmailPattern := regexp.MustCompile(`SHIP TO:\s*(\S+@[^ ]+?\.com)`)
	buyerEmailPattern := regexp.MustCompile(`SHIP TO:\s*(.*?)Lot#`)
	buyerEmailMatch := buyerEmailPattern.FindStringSubmatch(text)
	var buyerEmail string
	if len(buyerEmailMatch) > 1 {
		buyerEmail = strings.TrimSpace(buyerEmailMatch[1])
	}

	// Extract items
	var items []InvoiceItem
	itemPattern := regexp.MustCompile(`MSRP:\$\s*([\d.]+)\s+Y\d+\s+(\d+)T.*?Item handling fee -\s*([\d.]+)`)
	itemMatches := itemPattern.FindAllStringSubmatch(text, -1)
	for _, match := range itemMatches {
		unitPrice, _ := strconv.ParseFloat(match[1], 64)
		sku, _ := strconv.Atoi(match[2])
		itemHandlingFee, _ := strconv.ParseFloat(match[3], 64)
		description := "" // Add appropriate logic to extract description if necessary
		items = append(items, InvoiceItem{
			Sku:           sku,
			UnitPrice:     float32(unitPrice),
			ExtendedPrice: float32(unitPrice), // Assuming extended price is the same as unit price
			Desc:          description,
			HandlingFee:   float32(itemHandlingFee),
		})
	}

	return Invoice{
		AuctionLot:    auctionLot,
		BuyerName:     buyerName,
		Items:         items,
		Time:          time,
		BuyerEmail:    buyerEmail,
		BuyerAddress:  buyerAddress,
		BuyerPhone:    buyerPhone,
		InvoiceNumber: invoiceNumber,
	}
}

func CreateInvoiceFromPDF() gin.HandlerFunc {
	return func(c *gin.Context) {
		// ctx := context.Background()
		// get files from form
		// form, err := c.MultipartForm()
		// if err != nil {
		// 	c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		// 	return
		// }

		// open file from request
		file, header, err := c.Request.FormFile("file")
		if err != nil {
			c.String(http.StatusBadRequest, "Cannot Read File")
			return
		}
		defer file.Close()

		// Check the file extension
		if filepath.Ext(header.Filename) != ".pdf" {
			c.String(http.StatusBadRequest, "Please Only Upload PDF File")
			return
		}

		// check file size
		if header.Size > 10*1024*1024 {
			c.String(http.StatusBadRequest, "File Size Must Not Exceed 10 MB")
			return
		}

		// create temp file from buffer
		tmp, err := os.CreateTemp("./", "temp_*.pdf")
		if err != nil {
			fmt.Println(err.Error())
			c.String(http.StatusInternalServerError, "Error Creating Temp File: %v", err)
			return
		}
		fmt.Println(tmp.Name())
		defer os.Remove(tmp.Name())
		defer tmp.Close()

		// write data into tmp file
		_, err = io.Copy(tmp, file)
		if err != nil {
			c.String(http.StatusInternalServerError, "Error Writing Temp File: %v", err)
			return
		}

		// multiple pdf
		// // Loop through all files in data form
		// for name, files := range form.File {
		// 	// open every file and upload
		// 	for _, fileHeader := range files {
		// 		if fileHeader.Size > 10*1024*1024 {
		// 			c.String(http.StatusBadRequest, "File Size Must Not Exceed 10 MB")
		// 			break
		// 		}
		// 	}
		// 	fmt.Println(name)
		// }

		// load with dslipakr pfd library
		f, openErr := pdf.Open(tmp.Name())
		if openErr != nil {
			fmt.Println(openErr.Error())
			c.String(http.StatusInternalServerError, openErr.Error())
			return
		}

		// read plain text into buffer
		var buf bytes.Buffer
		reader, textErr := f.GetPlainText()
		if textErr != nil {
			fmt.Println(textErr.Error())
			c.String(http.StatusInternalServerError, textErr.Error())
			return
		}
		buf.ReadFrom(reader)
		textToRemove := "Monday: CloseTuesday - Saturday: 12:00pm - 6:30pm"
		textToRemove2 := "CC Power Deals240 Bartor Road, Unit 4, North York, ON, M9M 2W6+1 416-740-2333"
		textToRemove3 := "READ NEW TERMS OF USE BEFORE YOU BID!"
		textToRemove4 := "READ EMAIL FOR PICK-UP & SHIPPING INSTRUCTIONS"
		textToRemove5 := "Sunday: CloseWe Asked All Items Should Check at Our Location"
		textToRemove6 := "NO RETURN AND REFUND"

		result_text := strings.ReplaceAll(buf.String(), textToRemove, "")
		result_text2 := strings.ReplaceAll(result_text, textToRemove2, "")
		result_text3 := strings.ReplaceAll(result_text2, textToRemove3, "")
		result_text4 := strings.ReplaceAll(result_text3, textToRemove4, "")
		result_text5 := strings.ReplaceAll(result_text4, textToRemove5, "")
		result_text6 := strings.ReplaceAll(result_text5, textToRemove6, "")
		// fmt.Println(buf.String())

		// err = os.Remove(tmp.Name())
		// if err != nil {
		// 	fmt.Println("Error deleting file:", err)
		// 	return
		// }

		fmt.Println(result_text6)
		res := parseInvoice(result_text6)

		// returns ok if success
		c.JSON(http.StatusOK, gin.H{
			"data": res,
			"size": header.Size,
		})
	}
}

type Range struct {
	Min float64 `json:"min"`
	Max float64 `json:"max"`
}

type InvoiceFilter struct {
	PaymentMethod     []*string   `json:"paymentMethod" binding:"required"`
	Status            []*string   `json:"status" binding:"required"`
	Shipping          *string     `json:"shipping" binding:"required"`
	DateRange         []time.Time `json:"dateRange" binding:"required"`
	InvoiceTotalRange Range       `json:"invoiceTotalRange" binding:"required"`
	Keyword           *string     `json:"keyword" binding:"required"`
}

type GetInvoiceRequest struct {
	CurrPage     *int           `json:"currPage" binding:"required"`
	ItemsPerPage *int           `json:"itemsPerPage" binding:"required"`
	Filter       *InvoiceFilter `json:"filter" binding:"required"`
	TimeOrder    *int           `json:"timeOrder" binding:"required"`
}

func GetInvoicesByPage(collection *mongo.Collection) gin.HandlerFunc {
	return func(c *gin.Context) {
		ctx := context.TODO()
		var body GetInvoiceRequest
		bindErr := c.ShouldBindJSON(&body)
		if bindErr != nil {
			fmt.Println(bindErr.Error())
			c.String(http.StatusBadRequest, "Invalid Body")
			return
		}

		fmt.Printf("CurrPage: %+v\n", *body.CurrPage)
		fmt.Printf("ItemsPerPage: %+v\n", *body.Filter)
		fmt.Printf("isShipping: %+v\n", *body.Filter.Shipping)

		// construct shipping filter
		shippingFilter := bson.D{{}}
		isShipping := *body.Filter.Shipping
		// all selection will exclude shipping from request body
		if isShipping != "" {
			// set key
			shippingFilter[0].Key = "isShipping"
			// set filter value
			if isShipping == "pickup" {
				shippingFilter[0].Value = false
			} else if isShipping == "shipping" {
				shippingFilter[0].Value = true
			}
		}

		// construct payment method filter
		// var invoiceTotalRange bson.D
		// totalRange := body.Filter.InvoiceTotalRange
		// invoiceTotalRange[0].Key = totalRange.Min

		// make mongo db filters
		fil := bson.D{
			{
				Key: "$and",
				Value: bson.A{
					shippingFilter,
				},
			},
		}

		// new query options setting sort and skip
		itemsPerPage := int64(*body.ItemsPerPage)
		opt := options.Find().SetSort(bson.D{{
			Key:   "time",
			Value: int32(*body.TimeOrder),
		}}).SetSkip(int64(*body.CurrPage) * itemsPerPage).SetLimit(itemsPerPage)

		// find items in database using above options
		cursor, err := collection.Find(ctx, fil, opt)
		if err != nil {
			fmt.Println(err)
			c.String(http.StatusInternalServerError, "Cannot Get From Database")
			return
		}
		defer cursor.Close(ctx) // close it after query

		// count items
		totalItemsFilterd, countErr := collection.CountDocuments(ctx, fil)
		if countErr != nil {
			c.String(http.StatusInternalServerError, "Cannot Get From Database")
			return
		}

		// store all result in bson array to return it
		var itemsArr []bson.M
		for cursor.Next(ctx) {
			var result bson.M
			err := cursor.Decode(&result)
			if err != nil {
				c.String(http.StatusInternalServerError, "Database Error!")
			}
			itemsArr = append(itemsArr, result)
		}

		// return the item info as json
		c.JSON(200, gin.H{
			"itemsArr":   itemsArr,
			"totalItems": totalItemsFilterd,
		})
	}
}

// datas for invoice controller charts
func GetChartData(collection *mongo.Collection) gin.HandlerFunc {
	return func(c *gin.Context) {

	}
}

// convert all time strings to RFC3339 format
func ConvertAllTimes(collection *mongo.Collection) gin.HandlerFunc {
	return func(c *gin.Context) {
		ctx := context.Background()
		cursor, err := collection.Find(ctx, bson.M{"time": bson.M{"$exists": true}}, nil)
		if err != nil {
			log.Fatal("cannot find")
		}
		defer cursor.Close(ctx)
		for cursor.Next(ctx) {
			var document bson.M
			err := cursor.Decode(&document)
			if err != nil {
				log.Fatal("cannot decode cursor")
			}
			parsedTime, err := time.Parse("1/2/2006, 3:04:05 PM", document["time"].(string))
			if err != nil {
				log.Fatal("cannot parse time")
			}
			newTime := parsedTime.Format(timeFormat)
			fmt.Println(newTime)
			updateOption := bson.M{
				"$set": bson.M{
					"time": newTime,
				},
			}
			_, updateErr := collection.UpdateOne(ctx, bson.M{"_id": document["_id"]}, updateOption)
			if updateErr != nil {
				log.Fatal("Cannot update")
			}
		}
		c.String(200, "Pass")
	}
}

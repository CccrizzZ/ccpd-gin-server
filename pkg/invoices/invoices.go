package invoices

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"log"
	"mime/multipart"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/dslipak/pdf"
	"github.com/gin-gonic/gin"
	"github.com/minio/minio-go/v7"
	"github.com/sashabaranov/go-openai"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

var timeFormat string = "2006-01-02T15:04:05Z07:00"

type Invoice struct {
	InvoiceNumber   string  `json:"invoiceNumber" binding:"required" validate:"required"`
	Time            string  `json:"time" binding:"required" validate:"required"`
	BuyerName       string  `json:"buyerName" binding:"required" validate:"required"`
	BuyerEmail      string  `json:"buyerEmail" binding:"required" validate:"required"`
	BuyerAddress    string  `json:"buyerAddress" binding:"required" validate:"required"`
	ShippingAddress string  `json:"shippingAddress" binding:"required" validate:"required"`
	BuyerPhone      string  `json:"buyerPhone" binding:"required" validate:"required"`
	AuctionLot      int     `json:"auctionLot" binding:"required" validate:"required"`
	InvoiceTotal    float32 `json:"invoiceTotal" binding:"required"`
	Message         string  `json:"message" binding:"required" validate:"required"`
	Items           []InvoiceItem
}

type InvoiceItem struct {
	Sku           int     `json:"sku"`
	Msrp          string  `json:"msrp"`
	ShelfLocation string  `json:"shelfLocation"`
	ItemLot       int     `json:"itemLot"`
	Desc          string  `json:"description"`
	Unit          int     `json:"unit"`
	UnitPrice     float32 `json:"unitPrice"`
	ExtendedPrice float32 `json:"extendedPrice"` // unit * unitPrice
	HandlingFee   float32 `json:"handlingFee"`
}

func CreateInvoice() gin.HandlerFunc {
	return func(c *gin.Context) {
		// ctx := context.Background()
		var newInvoice Invoice
		bindErr := c.ShouldBindJSON(&newInvoice)
		if bindErr != nil {
			c.String(http.StatusBadRequest, "Invalid Body")
			return
		}
	}
}

// upload single invoice pdf to digital ocean space object storage
// defaultting the CDN link to public viewable
func UploadInvoice(
	ctx context.Context,
	storageClient *minio.Client,
	file multipart.File,
	header *multipart.FileHeader,
) string {
	// upload pdf file to space object storage
	uploaded, uploadErr := storageClient.PutObject(
		ctx,
		"Invoices",
		header.Filename,
		file,
		header.Size,
		minio.PutObjectOptions{
			ContentType: header.Header.Get("Content-Type"),
			UserMetadata: map[string]string{
				"x-amz-acl": "public-read",
			},
		},
	)
	if uploadErr != nil {
		log.Fatal(uploadErr)
	}

	// construct CDN url
	cdnURL := fmt.Sprintf("https://%s.%s/%s/%s", "crm-258-storage", "nyc3.cdn.digitaloceanspaces.com", uploaded.Bucket, uploaded.Key)
	fmt.Println(cdnURL)
	return cdnURL
}

// split the invoice text into parts
// header, items rows, footer
func splitInvoice(text string) ([]string, error) {
	var splitArr []string

	// this split the body and header
	re := regexp.MustCompile(`PRICEEXTENDEDPRICE`)

	// get index of `PRICEEXTENDEDPRICE`
	index := re.FindStringIndex(text)

	// if found, store first part and rest in array
	var rest string
	if index != nil {
		header := text[:index[1]]
		fmt.Println(header)
		splitArr = append(splitArr, header)
		rest = text[index[1]:]
	} else {
		return splitArr, errors.New("cannot find PRICEEXTENDEDPRICE to split the header")
	}

	fmt.Println(rest)

	// // split the items and footer
	// itemRe := regexp.MustCompile(`MSRP:\s*\$[\d\.]+\s*([\w\s\-\.,'&;]*)\s*Item handling fee -`)
	// matches := itemRe.FindAllStringSubmatch(rest, -1)

	// // store all items in an array
	// var items []string
	// for _, match := range matches {
	// 	if len(match) > 1 {
	// 		items = append(items, strings.TrimSpace(match[1]))
	// 	}
	// }

	// print(items)

	return splitArr, nil
}

// generated by chat gpt
// parse the extracted text from pdf to object
func parseInvoice(text string) Invoice {
	// auction lot number
	auctionLotPattern := regexp.MustCompile(`Auction Sale - (\d+)`)
	auctionLotMatch := auctionLotPattern.FindStringSubmatch(text)
	var auctionLot int
	if len(auctionLotMatch) > 1 {
		auctionLot, _ = strconv.Atoi(auctionLotMatch[1])
	}

	// Extract invoice number
	invoiceNumberPattern := regexp.MustCompile(`\s+1\s+(\d+)\s*Auction Sale`)
	invoiceNumberMatch := invoiceNumberPattern.FindStringSubmatch(text)
	var invoiceNumber string
	if len(invoiceNumberMatch) > 1 {
		invoiceNumber = strings.TrimSpace(invoiceNumberMatch[1])
	}

	// Extract time
	timePattern := regexp.MustCompile(`(\d{1,2}/\d{1,2}/\d{4}\s+\d{1,2}:\d{2}:\d{2})`)
	timeMatch := timePattern.FindStringSubmatch(text)
	var time string
	if len(timeMatch) > 1 {
		time = strings.TrimSpace(timeMatch[1])
	}

	// buyer name & address
	buyerNamePattern := regexp.MustCompile(`SOLD TO:\s*(.*?)SHIP TO:`)
	buyerNameAddressMatch := buyerNamePattern.FindStringSubmatch(text)
	var buyerName string
	var buyerAddress string
	if len(buyerNameAddressMatch) > 1 {
		buyerInfo := strings.TrimSpace(buyerNameAddressMatch[1])
		// the name will follow by street number
		// split by street number
		re := regexp.MustCompile(`\d`)
		firstNumberIndex := re.FindStringIndex(buyerInfo)
		if firstNumberIndex != nil {
			buyerName = strings.TrimSpace(buyerInfo[:firstNumberIndex[0]])
			buyerAddress = strings.TrimSpace(buyerInfo[firstNumberIndex[0]:])
		} else {
			// if buyer address started with letter, its not gonna detect
			buyerName = buyerInfo
		}
	}

	// buyer phone
	buyerPhonePattern := regexp.MustCompile(`Phone:\s*(.*?)\s*#`)
	buyerPhoneMatch := buyerPhonePattern.FindStringSubmatch(text)
	var buyerPhone string
	if len(buyerPhoneMatch) > 1 {
		buyerPhone = strings.TrimSpace(buyerPhoneMatch[1])
		buyerPhone = strings.ReplaceAll(buyerPhone, "-", "")
		buyerPhone = strings.ReplaceAll(buyerPhone, " ", "")
	}

	// buyer email
	// buyerEmailPattern := regexp.MustCompile(`SHIP TO:\s*(\S+@[^ ]+?\.com)`)
	buyerEmailPattern := regexp.MustCompile(`SHIP TO:\s*(.*?)Lot#`)
	buyerEmailMatch := buyerEmailPattern.FindStringSubmatch(text)
	var buyerEmail string
	if len(buyerEmailMatch) > 1 {
		buyerEmail = strings.TrimSpace(buyerEmailMatch[1])
	}

	// Extract items
	var items []InvoiceItem
	itemPattern := regexp.MustCompile(`MSRP:\$\s*([\d.]+)\s+Y\d+\s+(\d+)T.*?Item handling fee -\s*([\d.]+)`)
	itemMatches := itemPattern.FindAllStringSubmatch(text, -1)
	for _, match := range itemMatches {
		unitPrice, _ := strconv.ParseFloat(match[1], 64)
		sku, _ := strconv.Atoi(match[2])
		itemHandlingFee, _ := strconv.ParseFloat(match[3], 64)
		items = append(items, InvoiceItem{
			Sku:           sku,
			UnitPrice:     float32(unitPrice),
			ExtendedPrice: float32(unitPrice),
			Desc:          "", // pull from db
			HandlingFee:   float32(itemHandlingFee),
		})
	}

	return Invoice{
		AuctionLot:    auctionLot,
		BuyerName:     buyerName,
		Items:         items,
		Time:          time,
		BuyerEmail:    buyerEmail,
		BuyerAddress:  buyerAddress,
		BuyerPhone:    buyerPhone,
		InvoiceNumber: invoiceNumber,
	}
}

func parseInvoiceWithGPT(text string) (Invoice, error) {
	ctx := context.Background()
	var newInvoice Invoice
	// pull open ai key
	openAIKey := os.Getenv("OPENAI_API_KEY")
	if openAIKey == "" {
		return newInvoice, errors.New("cannot get chat gpt key")
	}

	fmt.Println(text)

	// create gpt client
	client := openai.NewClient(openAIKey)

	// create prompt
	prompt := "Convert the following text extracted from a PDF document into an array of objects with appropriate fields:\n\n"
	prompt += text
	// prompt += "\nThe result should be an JSON object. Each string should be appropriately converted into fields of an object. the out put shoud follow this structure: \n\n"
	prompt += `
	export type Invoice = {
		invoiceNumber: number,
		buyerName: string,
		buyerEmail: string,
		buyerAddress: string,
		paymentMethod: PaymentMethod,
		auctionLot: number,
		invoiceTotal: number,
		buyersPremium: number,
		totalHandlingFee: number,
		status: InvoiceStatus,
		isShipping: boolean,
		time: string,
		timePickedup: string,
		items: InvoiceItem[],
	} \n

	export type InvoiceItem = {
		sku: number
		unit: number,
		unitPrice: number,
		extendedPrice: number,
		handlingFee: number,
	} \n`

	prompt += `
	when the input is: \n
	"        1      16105Auction Sale - 132 - HIGH/VALUE BOXES/BULK/ELECTRONIC(132)2023-09-25 10:37:54Invoice #:Date:Page:UNPAID2023-09-25 payment declined **2601Grace RoyGrace1600-2300 Young StreetToronto, ON M4P1E4CanadaPhone:647-773-1253# 7104SOLD TO:julius_roy@msn.comLot#DESCRIPTIONQUANTITYUNIT PRICEEXTENDEDPRICE1 x 5.00        5.00Farm Innovators Model HPFLITTLE CRACKED - UNTEST - Farm Innovators Model HPF-100"All-Seasons" Heated Plastic Poultry Fountain, 3 Gallon, Red/White,100-Watt MSRP:$ 74.96 K22 1976T528Item handling fee -         1.00 T  ------------------------------------1 x 5.00        5.00Trampoline Frame Size Replacement NettingN1-1216100000 12 ft. Trampoline Frame Size Replacement NettingMSRP:$ 99.99 H12 10854T788Item handling fee -         1.00 T  ------------------------------------         10.00         1.50Total Extended Price:15% Buyer's Premium:Item handling fee:           2.00          2.00Total Quantity:        1.76Tax1  Default:        $15.26        $15.26Invoice Total:Remaining Invoice Balance:                                  FOR ALL SOLD AS IS ITEMS" \n
	the output should be exactly like with only one object inside the array: \n
		[{
			"invoiceNumber": 16105,
			"buyerName": "Grace Roy",
			"buyerEmail": "julius_roy@msn.com",
			"buyerAddress": "1600-2300 Young Street, Toronto, ON M4P1E4, Canada",
			"shippingAddress": "",
			"paymentMethod": "",
			"auctionLot": 132,
			"invoiceTotal": 15.26,
			"buyersPremium": 1.50,
			"totalHandlingFee": 2.00,
			"status": "UNPAID",
			"isShipping": false,
			"time": "2023-09-25T10:37:54",
			"timePickedup": "",
			"items": [
				{
					"sku": 1976T528,
					"unit": 1,
					"unitPrice": 5.00,
					"extendedPrice": 5.00,
					"handlingFee": 1.00
				},
				{
					"sku": 10854T788,
					"unit": 1,
					"unitPrice": 5.00,
					"extendedPrice": 5.00,
					"handlingFee": 1.00
				}
			]
		}]
	`
	prompt += `If the input string contains "SHIP TO", there are two addresses in there, the first one is "BuyerAddress", the second one is "ShippingAddress", if not set ShippingAddress to nil ("") \n`
	// prompt += `The "shelfLocation" will always follow MSRP, starts with an letter followed by 1 or 2 (maximum 3) digit numbers,
	// the SKU is always the number before "T", the lot number is always the number after "T"
	// in case where the input is "MSRP:$ 69.46 Y43 26430T1496Item handling fee" should produce: {MSRP: "64.96", shelfLocation: "Y43", SKU: "26430" ,ItemLot: "1496"} the MSRP should be numbers only (without $ sign) \n`
	prompt += `the SKU will be both "1976T528" where the input is "1976T528Item handling fee" \n`
	prompt += `"paymentMethod" should be empty string ("") if UNPAID mentioned in the input \n`
	prompt += `the result JSON Array should ONLY have one Invoice object that contains items from all pages \n`

	// call gpt api
	res, err := client.CreateChatCompletion(
		ctx,
		openai.ChatCompletionRequest{
			Model:       openai.GPT3Dot5Turbo,
			MaxTokens:   4000,
			Temperature: 0,
			Messages: []openai.ChatCompletionMessage{{
				Role:    openai.ChatMessageRoleUser,
				Content: prompt,
			}},
		},
	)
	if err != nil {
		return newInvoice, errors.New("cannot get gpt result")
	}
	fmt.Println(res.Choices[0].Message.Content)
	return newInvoice, nil
}

func extractInvoiceData(rawString string) Invoice {
	// Clean up the input string
	cleanedString := strings.TrimSpace(rawString)

	// Define regular expressions for different parts
	invoiceNumberRe := regexp.MustCompile(`Invoice #:\s*(\d+)`)
	timeRe := regexp.MustCompile(`(\d{1,2}/\d{1,2}/\d{4} \d{1,2}:\d{2}:\d{2})`)
	buyerNameRe := regexp.MustCompile(`#\s*\d+\s*([\w\s]+)\s*\d+`)
	buyerEmailRe := regexp.MustCompile(`SOLD TO:\s*(\S+)`)
	buyerAddressRe := regexp.MustCompile(`([\d\w\s]+),\s*(\w+),\s*(\w+),\s*(\w+\s*\d+)`)
	buyerPhoneRe := regexp.MustCompile(`Phone:(\d+)`)
	auctionLotRe := regexp.MustCompile(`#\s*(\d+)`)
	invoiceTotalRe := regexp.MustCompile(`Invoice Total:\s*\$([\d\.]+)`)

	// Extract data using the regular expressions
	invoiceNumber := invoiceNumberRe.FindStringSubmatch(cleanedString)[1]
	time := timeRe.FindStringSubmatch(cleanedString)[1]
	buyerName := buyerNameRe.FindStringSubmatch(cleanedString)[1]
	buyerEmail := buyerEmailRe.FindStringSubmatch(cleanedString)[1]
	buyerAddressMatches := buyerAddressRe.FindStringSubmatch(cleanedString)
	buyerAddress := strings.Join(buyerAddressMatches[1:], ", ")
	buyerPhone := buyerPhoneRe.FindStringSubmatch(cleanedString)[1]
	auctionLot, _ := strconv.Atoi(auctionLotRe.FindStringSubmatch(cleanedString)[1])
	invoiceTotal, _ := strconv.ParseFloat(invoiceTotalRe.FindStringSubmatch(cleanedString)[1], 64)

	// Extract items
	items := extractInvoiceItems(cleanedString)

	return Invoice{
		InvoiceNumber:   invoiceNumber,
		Time:            time,
		BuyerName:       buyerName,
		BuyerEmail:      buyerEmail,
		BuyerAddress:    buyerAddress,
		ShippingAddress: buyerAddress, // Assuming shipping address is the same
		BuyerPhone:      buyerPhone,
		AuctionLot:      auctionLot,
		InvoiceTotal:    float32(invoiceTotal),
		Items:           items,
	}
}

func extractInvoiceItems(cleanedString string) []InvoiceItem {
	itemRe := regexp.MustCompile(`(\d+ x \d+\.\d+)\s*(\d+\.\d+)\s*([\w\s\-]+)\s*([\w\s\-]+)\s*MSRP:\$([\d\.]+)\s*(\w\d+)\s*(\d+)T(\d+)\s*Item handling fee\s*\-\s*(\d+\.\d+)`)
	itemMatches := itemRe.FindAllStringSubmatch(cleanedString, -1)

	var items []InvoiceItem
	for _, match := range itemMatches {
		unit, _ := strconv.Atoi(strings.Split(match[1], " x ")[0])
		unitPrice, _ := strconv.ParseFloat(strings.Split(match[1], " x ")[1], 64)
		extendedPrice, _ := strconv.ParseFloat(match[2], 64)
		handlingFee, _ := strconv.ParseFloat(match[9], 64)
		sku, _ := strconv.Atoi(match[6])
		itemLot, _ := strconv.Atoi(match[8])

		item := InvoiceItem{
			Sku:           sku,
			Msrp:          match[5],
			ShelfLocation: match[6],
			ItemLot:       itemLot,
			Desc:          match[3] + " " + match[4],
			Unit:          unit,
			UnitPrice:     float32(unitPrice),
			ExtendedPrice: float32(extendedPrice),
			HandlingFee:   float32(handlingFee),
		}
		items = append(items, item)
	}

	return items
}

// this one only process UNPAID invoice pdf
func CreateInvoiceFromPDF(storageClient *minio.Client) gin.HandlerFunc {
	return func(c *gin.Context) {
		ctx := context.Background()
		// get files from form
		// form, err := c.MultipartForm()
		// if err != nil {
		// 	c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		// 	return
		// }

		// parse upload pdf option from form value
		uploadPDF := c.Request.FormValue("uploadPDF")
		toUpload, err := strconv.ParseBool(uploadPDF)
		if err != nil {
			c.String(http.StatusBadRequest, "No Upload PDF Option Passed")
		}

		// open file from request
		file, header, err := c.Request.FormFile("file")
		if err != nil {
			c.String(http.StatusBadRequest, "Cannot Read File")
			return
		}
		defer file.Close()

		// Check the file extension
		if filepath.Ext(header.Filename) != ".pdf" {
			c.String(http.StatusBadRequest, "Please Only Upload PDF File")
			return
		}

		// check file size
		if header.Size > 10*1024*1024 {
			c.String(http.StatusBadRequest, "File Size Must Not Exceed 10 MB")
			return
		}

		// check if bucket exist
		exists, existErr := storageClient.BucketExists(ctx, "Invoices")
		if existErr != nil || !exists {
			c.String(http.StatusInternalServerError, "Bucket Not Exist")
			return
		}

		// upload invoice to space object storage if uploadPDF in form is true
		if toUpload {
			cdnLink := UploadInvoice(ctx, storageClient, file, header)
			fmt.Println(cdnLink)
		}

		// create temp file from buffer
		tmp, createErr := os.CreateTemp("./", "*.pdf")
		if createErr != nil {
			c.String(http.StatusInternalServerError, "Error Creating Temp File: %v", createErr.Error())
			return
		}
		defer func() {
			closeErr := tmp.Close()
			if closeErr != nil {
				fmt.Println(closeErr.Error())
			}
			removeErr := os.Remove(tmp.Name())
			if removeErr != nil {
				fmt.Println(removeErr.Error())
			}
		}()

		// write data into tmp file
		var _, copyErr = io.Copy(tmp, file)
		if copyErr != nil {
			c.String(http.StatusInternalServerError, "Error Writing Temp File: %v", copyErr.Error())
			return
		}

		// multiple pdf
		// // Loop through all files in data form
		// for name, files := range form.File {
		// 	// open every file and upload
		// 	for _, fileHeader := range files {
		// 		if fileHeader.Size > 10*1024*1024 {
		// 			c.String(http.StatusBadRequest, "File Size Must Not Exceed 10 MB")
		// 			break
		// 		}
		// 	}
		// 	fmt.Println(name)
		// }

		// get file size
		tmpFileInformation, fileInfoErr := tmp.Stat()
		if fileInfoErr != nil {
			tmp.Close()
			c.String(http.StatusInternalServerError, fileInfoErr.Error())
		}

		// make reader
		pdfObj, readerErr := pdf.NewReader(tmp, tmpFileInformation.Size())
		if readerErr != nil {
			tmp.Close()
			c.String(http.StatusInternalServerError, readerErr.Error())
		}

		// read plain text into buffer
		var buf bytes.Buffer
		reader, textErr := pdfObj.GetPlainText()
		if textErr != nil {
			fmt.Println(textErr.Error())
			c.String(http.StatusInternalServerError, textErr.Error())
			return
		}
		buf.ReadFrom(reader)

		// remove header and footer
		textToRemoveArr := []string{
			"Monday: CloseTuesday - Saturday: 12:00pm - 6:30pm",
			"CC Power Deals240 Bartor Road, Unit 4, North York, ON, M9M 2W6+1 416-740-2333",
			"READ NEW TERMS OF USE BEFORE YOU BID!",
			"READ EMAIL FOR PICK-UP & SHIPPING INSTRUCTIONS",
			"Sunday: CloseWe Asked All Items Should Check at Our Location",
			"NO RETURN AND REFUND",
			"#:Date:Page:UNPAIDLot#DESCRIPTIONUNIT PRICEEXTENDEDPRICE",
		}
		extractedText := buf.String()
		for _, val := range textToRemoveArr {
			extractedText = strings.ReplaceAll(extractedText, val, "")
		}

		// parse text with chat gpt
		// res, gptErr := parseInvoiceWithGPT(extractedText)
		// if gptErr != nil {
		// 	fmt.Println(gptErr.Error())
		// 	c.String(http.StatusInternalServerError, gptErr.Error())
		// }
		re, splitErr := splitInvoice(extractedText)
		if splitErr != nil {
			fmt.Println(textErr.Error())
			c.String(http.StatusInternalServerError, splitErr.Error())
			return
		}
		res := parseInvoice(extractedText)
		// res := extractInvoiceData(extractedText)
		fmt.Println(re)

		// return invoice object
		c.JSON(http.StatusOK, gin.H{
			"data": res,
		})
	}
}

type Range struct {
	Min float64 `json:"min"`
	Max float64 `json:"max"`
}

type InvoiceFilter struct {
	// DateRange         []time.Time `json:"dateRange" binding:"required"`
	PaymentMethod     []string `json:"paymentMethod" binding:"required"`
	Status            []string `json:"status" binding:"required"`
	Shipping          *string  `json:"shipping" binding:"required"`
	FromDate          string   `json:"fromDate"`
	ToDate            string   `json:"toDate"`
	InvoiceTotalRange Range    `json:"invoiceTotalRange" binding:"required"`
	Keyword           *string  `json:"keyword" binding:"required"`
	InvoiceNumber     int      `json:"invoiceNumber"`
}

type GetInvoiceRequest struct {
	CurrPage     *int           `json:"currPage" binding:"required"`
	ItemsPerPage *int           `json:"itemsPerPage" binding:"required"`
	Filter       *InvoiceFilter `json:"filter" binding:"required"`
	TimeOrder    *int           `json:"timeOrder" binding:"required"`
}

func GetInvoicesByPage(collection *mongo.Collection) gin.HandlerFunc {
	return func(c *gin.Context) {
		ctx := context.TODO()
		var body GetInvoiceRequest
		bindErr := c.ShouldBindJSON(&body)
		if bindErr != nil {
			fmt.Println(bindErr.Error())
			c.String(http.StatusBadRequest, "Invalid Body")
			return
		}

		// make date range filter
		timeFilter := bson.M{}
		if body.Filter.FromDate != "" {
			timeFilter["$gte"] = body.Filter.FromDate
		}
		if body.Filter.ToDate != "" {
			timeFilter["$lte"] = body.Filter.ToDate
		} else if body.Filter.FromDate != "" {
			// if only fromdate input and no todate
			// set todate to next day of fromdate
			dateObj, err := time.Parse(time.RFC3339, body.Filter.FromDate)
			if err != nil {
				fmt.Println("Error Parsing toDate:", err)
				return
			}
			newDate := dateObj.Add(24 * time.Hour)
			timeFilter["$lte"] = newDate.Format(time.RFC3339)
		}
		dateRangeFilter := bson.D{{
			Key:   "time",
			Value: timeFilter,
		}}

		// multiple payment method choices
		paymentMethodFilter := bson.D{{
			Key:   "$or",
			Value: nil,
		}}
		if len(body.Filter.PaymentMethod) > 0 {
			// loop all payment method, populate $or filter
			var tempArr = bson.A{}
			for _, val := range body.Filter.PaymentMethod {
				tempArr = append(tempArr, bson.M{"paymentMethod": val})
			}
			paymentMethodFilter[0].Value = tempArr
		}

		// invoice status filter
		statusFilter := bson.D{{
			Key:   "$or",
			Value: nil,
		}}
		if len(body.Filter.Status) > 0 {
			var tempArr = bson.A{}
			for _, val := range body.Filter.Status {
				tempArr = append(tempArr, bson.M{"status": val})
			}
			statusFilter[0].Value = tempArr
		}

		// construct shipping filter
		shippingFilter := bson.D{{}}
		isShipping := *body.Filter.Shipping
		// all selection will exclude shipping from request body
		if isShipping != "" {
			// set key
			shippingFilter[0].Key = "isShipping"
			// set filter value
			if isShipping == "pickup" {
				shippingFilter[0].Value = false
			} else if isShipping == "shipping" {
				shippingFilter[0].Value = true
			}
		}

		// construct payment method filter
		totalFilter := bson.M{}
		minInvoiceTotal := body.Filter.InvoiceTotalRange.Min
		if minInvoiceTotal != 0 {
			totalFilter["$gte"] = minInvoiceTotal
		}
		maxInvoiceTotal := body.Filter.InvoiceTotalRange.Max
		if maxInvoiceTotal != 999999 {
			totalFilter["$lte"] = maxInvoiceTotal
		}
		invoiceTotalFilter := bson.D{{
			Key:   "invoiceTotal",
			Value: totalFilter,
		}}

		// keyword filter
		kwFilter := bson.D{{
			Key:   "$or",
			Value: nil,
		}}
		words := strings.Fields(*body.Filter.Keyword)
		fmt.Println(words)
		if len(words) > 0 {
			var tempArr = bson.A{}
			for _, val := range words {
				tempArr = append(tempArr, bson.M{"buyerAddress": bson.M{"$regex": val}})
				tempArr = append(tempArr, bson.M{"buyerEmail": bson.M{"$regex": val}})
				tempArr = append(tempArr, bson.M{"buyerName": bson.M{"$regex": val}})
			}
			kwFilter[0].Value = tempArr
		}

		// invoice number
		invoiceNumberFilter := bson.M{}
		// number, convertErr := strconv.Atoi(body.Filter.InvoiceNumber)
		if body.Filter.InvoiceNumber != 0 {
			invoiceNumberFilter["invoiceNumber"] = body.Filter.InvoiceNumber
		}

		// make mongodb query filter
		andFilters := bson.A{
			shippingFilter,
			invoiceNumberFilter,
		}
		// if payment method passed in, append payment method filter
		if paymentMethodFilter[0].Value != nil {
			andFilters = append(andFilters, paymentMethodFilter)
		}
		// same with invoice status
		if statusFilter[0].Value != nil {
			andFilters = append(andFilters, statusFilter)
		}
		if kwFilter[0].Value != nil {
			andFilters = append(andFilters, kwFilter)
		}
		// if one of the date range passed in, append the date filter
		if timeFilter["$gte"] != nil || timeFilter["$lte"] != nil {
			andFilters = append(andFilters, dateRangeFilter)
		}
		if totalFilter["$gte"] != nil || totalFilter["$lte"] != nil {
			andFilters = append(andFilters, invoiceTotalFilter)
		}
		fil := bson.D{
			{
				Key:   "$and",
				Value: andFilters,
			},
		}
		fmt.Println(fil)

		// new query options setting sort and skip
		itemsPerPage := int64(*body.ItemsPerPage)
		opt := options.Find().SetSort(bson.D{{
			Key:   "time",
			Value: int32(*body.TimeOrder),
		}}).SetSkip(int64(*body.CurrPage) * itemsPerPage).SetLimit(itemsPerPage)

		// find items in database using above options
		cursor, err := collection.Find(ctx, fil, opt)
		if err != nil {
			fmt.Println(err)
			c.String(http.StatusInternalServerError, "Cannot Get From Database")
			return
		}
		defer cursor.Close(ctx) // close it after query

		// count filtered items
		totalItemsFilterd, countErr := collection.CountDocuments(ctx, fil)
		if countErr != nil {
			c.String(http.StatusInternalServerError, "Cannot Get From Database")
			return
		}

		// store all result in array of objects
		var itemsArr []bson.M
		for cursor.Next(ctx) {
			var result bson.M
			err := cursor.Decode(&result)
			if err != nil {
				c.String(http.StatusInternalServerError, "Database Error!")
			}
			itemsArr = append(itemsArr, result)
		}

		// return the item info as json
		c.JSON(200, gin.H{
			"itemsArr":   itemsArr,
			"totalItems": totalItemsFilterd,
		})
	}
}

// datas for invoice controller charts
func GetChartData(collection *mongo.Collection) gin.HandlerFunc {
	return func(c *gin.Context) {

	}
}

// convert all time strings to RFC3339 format
func ConvertAllTimes(collection *mongo.Collection) gin.HandlerFunc {
	return func(c *gin.Context) {
		ctx := context.Background()
		cursor, err := collection.Find(ctx, bson.M{"time": bson.M{"$exists": true}}, nil)
		if err != nil {
			log.Fatal("cannot find")
		}
		defer cursor.Close(ctx)
		for cursor.Next(ctx) {
			var document bson.M
			err := cursor.Decode(&document)
			if err != nil {
				log.Fatal("cannot decode cursor")
			}
			parsedTime, err := time.Parse("1/2/2006, 3:04:05 PM", document["time"].(string))
			if err != nil {
				log.Fatal("cannot parse time")
			}
			newTime := parsedTime.Format(timeFormat)
			fmt.Println(newTime)
			updateOption := bson.M{
				"$set": bson.M{
					"time": newTime,
				},
			}
			_, updateErr := collection.UpdateOne(ctx, bson.M{"_id": document["_id"]}, updateOption)
			if updateErr != nil {
				log.Fatal("Cannot update")
			}
		}
		c.String(200, "Pass")
	}
}
